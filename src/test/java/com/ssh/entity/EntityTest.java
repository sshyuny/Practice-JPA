package com.ssh.entity;
import static org.junit.jupiter.api.Assertions.assertThrows;

import org.hibernate.exception.ConstraintViolationException;
import org.hibernate.id.IdentifierGenerationException;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import com.ssh.entity.entityMapping.Jindo;
import com.ssh.entity.entityMapping.Husky;
import com.ssh.entity.entityMapping.Retriever;
import com.ssh.entity.tableMapping.Blue;
import com.ssh.entity.tableMapping.BlueType;

import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.EntityTransaction;
import jakarta.persistence.Persistence;

public class EntityTest {

    static EntityManagerFactory emf;
    static EntityManager em;
    static EntityTransaction tx;
    
    @BeforeAll
    static void beforeAll() {
        emf = Persistence.createEntityManagerFactory("jpa-practice");
        em = emf.createEntityManager();
        tx = em.getTransaction();

        tx.begin();
    }
    @AfterAll
    static void afterAll() {
        tx.commit();
        em.close();
        emf.close();
    }


    @Test
    void 컬럼매핑_컬럼DDL() {
        // Hibernate: 
        // create table Cat (
        //     size integer not null,
        //     CAT_ID bigint generated by default as identity,
        //     name varchar(64) not null,                                <- DDL 적용된 부분!
        //     catBreed enum ('KOREAN_SHORTHAIR','AMERICAN_SHORTHAIR','BRAZILIAN_SHORTHAIR'),
        //     detail clob,
        //     primary key (CAT_ID)
        // )
    }

    @Test
    void 테이블매핑_테이블DDL() {
        Blue blue1 = new Blue();
        blue1.setBlueType(BlueType.BABYBLUE);
        blue1.setTransparent(3);

        Blue blue2 = new Blue();
        blue2.setBlueType(BlueType.BABYBLUE);
        blue2.setTransparent(3);

        em.persist(blue1);
        
        // DDL로 유니크 설정하여, 동일한 데이터 예외 발생함!
        assertThrows(ConstraintViolationException.class, () -> {
            em.persist(blue2);
        });

        // org.hibernate.exception.ConstraintViolationException: could not execute statement [Unique index or primary key violation: "PUBLIC.TRANSPARENT_TYPE_UNIQUE_INDEX_1 ON PUBLIC.BLUE(TRANSPARENT, BLUETYPE) VALUES 1"
        // ERROR: Unique index or primary key violation: "PUBLIC.TRANSPARENT_TYPE_UNIQUE_INDEX_1 ON PUBLIC.BLUE(TRANSPARENT, BLUETYPE) VALUES 1"; SQL statement:

        // Hibernate: 
        // create table BLUE (
        //     transparent integer,
        //     BLUE_ID bigint generated by default as identity,
        //     blueType enum ('SKYBLUE','BABYBLUE','COBALT'),
        //     primary key (BLUE_ID),
        //     constraint TRANSPARENT_TYPE_UNIQUE unique (transparent, blueType)         <- DDL 적용된 부분!
        // )
    }

    @Test
    void 기본키매핑_직접할당전략() {

        // [정상 상황]
        Husky husky = new Husky();
        husky.setId("husky");
        husky.setName("허스키");
        em.persist(husky);

        // [예외 상황]
        Husky huskyEx = new Husky();
        huskyEx.setName("예외 허스키");
        
        // 직접할당전략에서 id 할당 안할시 예외 발생
        assertThrows(IdentifierGenerationException.class , () -> {
            em.persist(huskyEx);
        });
    }

    @Test
    void 기본키매핑_시퀀스전략() {

        for (int i = 0; i < 20; i++) {
            Jindo jindo = new Jindo();
            em.persist(jindo);
            System.out.println(i + " 번째 진돌이 저장");
        }

        // 시퀀스 값 조회 후 기본키를 매핑함을 확인할수있다!
        
        // ==== JPA 출력 로그 ====

        // create sequence JINDO_SEQ start with 1 increment by 4
        // ...
        // Hibernate: 
        //     select
        //         next value for JINDO_SEQ
        // 0 번째 진돌이 저장
        // Hibernate: 
        //     select
        //         next value for JINDO_SEQ
        // 1 번째 진돌이 저장
        // 2 번째 진돌이 저장
        // 3 번째 진돌이 저장
        // 4 번째 진돌이 저장
        // Hibernate: 
        //     select
        //         next value for JINDO_SEQ
        // 5 번째 진돌이 저장
        // 6 번째 진돌이 저장
        // 7 번째 진돌이 저장
        // 8 번째 진돌이 저장
    }

    @Test
    void 기본키매핑_테이블전략() {

        for (int i = 0; i < 10; i++) {
            Retriever retriever = new Retriever();
            em.persist(retriever);
            System.out.println(i + "번: " + retriever.getId() + " id로 저장!");
        }

        // Hibernate: 
        // create table MY_SEQUENCES (
        //     next_val bigint,
        //     sequence_name varchar(255) not null,
        //     primary key (sequence_name)
        // )
        // Hibernate: 
        // insert into MY_SEQUENCES(sequence_name, next_val) values ('RETRIEVER_SEQ',0)

        // Hibernate: 
        //     select
        //         tbl.next_val 
        //     from
        //         MY_SEQUENCES tbl 
        //     where
        //         tbl.sequence_name=? for update
        // Hibernate: 
        //     update
        //         MY_SEQUENCES 
        //     set
        //         next_val=?  
        //     where
        //         next_val=? 
        //         and sequence_name=?
        // 0번: 1 id로 저장!
        // Hibernate: 
        //     select
        //         tbl.next_val 
        //     from
        //         MY_SEQUENCES tbl 
        //     where
        //         tbl.sequence_name=? for update
        // Hibernate: 
        //     update
        //         MY_SEQUENCES 
        //     set
        //         next_val=?  
        //     where
        //         next_val=? 
        //         and sequence_name=?
        // 1번: 2 id로 저장!
        // 2번: 3 id로 저장!
    }

}
